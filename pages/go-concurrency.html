<div class="section">
  <h1>Why Go Was Built for Concurrency</h1>
  <p>
    Imagine you're at Google in 2007, tasked with building huge systems that
    handle millions of requests. The programming languages available then made
    this really hard. This is exactly what Rob Pike, Robert Griesemer, and Ken
    Thompson faced, which inspired them to create Go.
  </p>

  <p>
    Now, we'll look at the problems they needed to solve and how Go's design
    fixes them. This will show us why Go works so well when handling many tasks
    at the same time.
  </p>

  <div class="code-section">
    <h3>Basic Concurrency Example</h3>
    <div
      id="basic-example"
      class="code-container"
      data-code-path="go-concurrency/basic-example.go"
    ></div>
  </div>
  <div class="thought-exercise">
    <div class="thought-exercise-header">
        <span class="thought-exercise-emoji">ðŸ¤”</span>
        <h4 class="thought-exercise-title">Thought Exercise:</h4>
    </div>
    <div class="thought-exercise-content">
        Look at your computer's task manager or activity monitor right now.
        <div class="thought-exercise-questions">
            How many cores does your CPU have? How many programs are running simultaneously?
        </div>
    </div>
</div>
  <p>
    The world moved from single-core to multi-core processors, but many
    programming languages didn't change much. Most programming languages were
    designed much before the multi core processor shift. It's like having a
    kitchen with multiple chefs (cores) but giving them instructions written for
    a single chef!
  </p>
  <div class="characteristics">
    <h2>The Three Pillars of Go's Concurrency</h2>
    <ul>
      <li>
        <span class="key-term">Goroutines: Lightweight Threads</span>
        <p>
          Traditional threads like full-service restaurants, and goroutines like
          food trucks. A restaurant needs a lot of infrastructure - a permanent
          building, full kitchen equipment, dedicated staff, and extensive
          utilities. They're powerful but expensive to set up and maintain, and
          there's a practical limit to how many restaurants you can operate in
          an area.
        </p>
        <p>
          Goroutines are like food trucks - they're lightweight, flexible, and
          efficient. You can easily have dozens of food trucks operating in the
          same space where you might fit just one or two restaurants. Food
          trucks can quickly start up, serve their purpose, and move on. They
          share resources efficiently (like common eating areas) and can easily
          coordinate with each other.
        </p>
        <p>
          Just as a city can support thousands of food trucks more easily than
          thousands of full restaurants, a Go program can efficiently manage
          thousands of goroutines compared to traditional threads. When a food
          truck finishes serving its customers, it simply packs up and leaves -
          similar to how goroutines gracefully exit when their task is complete,
          freeing up resources for others.
        </p>
      </li>
    </ul>
  </div>

  <div class="navigation-buttons">
    <button class="nav-button" onclick="navigate('prev')">Previous</button>
    <button class="nav-button" onclick="navigate('next')">Next</button>
  </div>
</div>
