<div class="section">
  <h1>Why Go Was Built for Concurrency</h1>
  <p>
    Imagine you're at Google in 2007, tasked with building huge systems that
    handle millions of requests. The programming languages available then made
    this really hard. This is exactly what Rob Pike, Robert Griesemer, and Ken
    Thompson faced, which inspired them to create Go.
  </p>

  <p>
    Now, we'll look at the problems they needed to solve and how Go's design
    fixes them. This will show us why Go works so well when handling many tasks
    at the same time.
  </p>

  <div class="code-section">
    <h3>Basic Concurrency Example</h3>
    <div
      id="basic-example"
      class="code-container"
      data-code-path="go-concurrency/basic-example.go"
    ></div>
  </div>
  <div class="thought-exercise">
    <div class="thought-exercise-header">
      <span class="thought-exercise-emoji">ü§î</span>
      <h4 class="thought-exercise-title">Thought Exercise:</h4>
    </div>
    <div class="thought-exercise-content">
      Look at your computer's task manager or activity monitor right now.
      <div class="thought-exercise-questions">
        How many cores does your CPU have? How many programs are running
        simultaneously?
      </div>
    </div>
  </div>
  <p>
    The world moved from single-core to multi-core processors, but many
    programming languages didn't change much. Most programming languages were
    designed much before the multi core processor shift. It's like having a
    kitchen with multiple chefs (cores) but giving them instructions written for
    a single chef!
  </p>
  <div class="characteristics">
    <h2>The Three Pillars of Go's Concurrency</h2>
    <ul>
      <li>
        <span class="key-term">Goroutines: Lightweight Threads</span>
        <p>
          Traditional threads are like full-time employees - they need their own
          office (memory space), benefits package (resources), and have
          significant overhead. Goroutines are like task-based contractors -
          lightweight, flexible, and you can have thousands of them!
        </p>
        <div class="code-section">
          <h2>A Simple Goroutine</h2>
          <div
            id="basic-example"
            class="code-container"
            data-code-path="go-concurrency/goroutine.go"
          ></div>
        </div>
        <div class="thought-exercise">
          <div class="thought-exercise-header">
            <span class="thought-exercise-emoji">üîç</span>
            <h4 class="thought-exercise-title">Interactive Exercise:</h4>
          </div>
          <div class="thought-exercise-content">
            Try running this code with different numbers of goroutines. How many
            can your computer handle?
          </div>
        </div>
      </li>
      <li>
        <span class="key-term">The CSP Model: A Better Way to Communicate</span>
        <p>
          Remember playing with toy phones connected by a string as a kid?
          That's similar to how Go's channels work! Instead of sharing memory
          and risking conflicts, goroutines communicate by passing messages.
        </p>
      </li>
    </ul>
  </div>

  <div class="navigation-buttons">
    <button class="nav-button" onclick="navigate('prev')">Previous</button>
    <button class="nav-button" onclick="navigate('next')">Next</button>
  </div>
</div>
