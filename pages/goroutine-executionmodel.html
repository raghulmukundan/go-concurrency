<div class="section">
  <h1>Goroutine Execution Model</h1>
  <h2>Introduction to Goroutine Scheduling</h2>
  <p>
    When you launch a goroutine with the
    <span class="go-keyword">go</span> keyword, you're creating a lightweight
    unit of execution. But how does the Go runtime decide when each goroutine
    gets to run? This is where Go's scheduling model comes in.
  </p>
  <div class="code-section" style="margin: 1em 0 0 0">
    <div
      id="goroutine-execution-model"
      class="code-container"
      data-code-path="goroutine-execution/goroutine-sample.go"
    ></div>
  </div>
  <div class="thought-exercise">
    <div class="thought-exercise-header">
      <span class="thought-exercise-icon">
        <i class="fa-solid fa-brain"></i>
      </span>
      <h4 class="thought-exercise-title">Thought Exercise</h4>
    </div>
    <div class="thought-exercise-content">
      What Happens Behind the Scenes?
      <div class="thought-exercise-questions">
        Consider what might happen if you run 10,000 goroutines but only have 8
        CPU cores. How might Go handle this situation? Think about this before
        continuing.
      </div>
    </div>
  </div>

  <h2>Cooperative vs. Preemptive Scheduling</h2>
  <p>
    Goroutine scheduling has evolved over time, combining two primary
    approaches:
  </p>
  <h3>Cooperative Scheduling</h3>
  <p>
    In cooperative scheduling, a goroutine runs until it voluntarily yields
    control. Think of it as polite conversation - you speak until you decide to
    let someone else talk.
  </p>
  <div class="code-section" style="margin: 1em 0 0 0">
    <div
      id="goroutine-execution-model"
      class="code-container"
      data-code-path="goroutine-execution/cooperative-scheduling.go"
    ></div>
  </div>
  <div class="thought-exercise">
    <div class="thought-exercise-header">
      <span class="thought-exercise-icon">
        <i class="fa-solid fa-brain"></i>
      </span>
      <h4 class="thought-exercise-title">Thought Exercise</h4>
    </div>
    <div class="thought-exercise-content">
      What is <span class="code-inline">runtime.Gosched()</span> doing in the
      above code?
      <div class="thought-exercise-questions">
        The goroutine with <span class="code-inline">runtime.Gosched()</span> is
        stopping its execution and voluntarily giving away control so that other
        goroutines can run. This is cooperative scheduling in action.
      </div>
    </div>
  </div>

  <h3>Preemptive Scheduling</h3>
  <p>
    With preemptive scheduling, the Go runtime can interrupt a goroutine's
    execution even if it doesn't yield. This is like a teacher calling on a
    different student even if the current one isn't finished speaking.
  </p>
  <div class="code-section" style="margin: 1em 0 0 0">
    <div
      id="goroutine-execution-model"
      class="code-container"
      data-code-path="goroutine-execution/preemptive-scheduling.go"
    ></div>
  </div>
  <div class="thought-exercise">
    <div class="thought-exercise-header">
      <span class="thought-exercise-icon">
        <i class="fa-solid fa-brain"></i>
      </span>
      <h4 class="thought-exercise-title">Thought Exercise</h4>
    </div>
    <div class="thought-exercise-content">
      Run the above code multiple times. What do you notice?
      <div class="thought-exercise-questions">
        Even without a call to
        <span class="code-inline">runtime.Gosched()</span>, the goroutine with
        the CPU bound task will yield control to other goroutines. This is
        Preemptive scheduling in action. In the above code the for loop that
        runs for 1_000_000_000 iterations is a CPU bound task.
      </div>
    </div>
  </div>
  <h3>Problem with pure cooperative scheduling</h3>
  <p>
    Cooperative scheduling works great when goroutines play nice and yield
    often. But what about a goroutine that doesn’t? Imagine this:
  </p>
  <div class="code-section" style="margin: 1em 0 0 0">
    <div
      id="goroutine-execution-model"
      class="code-container norun"
      data-code-path="goroutine-execution/goroutine-problem.go"
    ></div>
  </div>
  <p>
    In older versions of Go (pre-1.14), this could be a problem. If a goroutine
    enters a tight loop with no yield points—like no function calls or blocking
    operations—it could hog the runtime indefinitely. Since the scheduler relies
    on cooperation, it wouldn’t get a chance to switch to other goroutines,
    including the main one. Your program might never print "Will I ever print?"
    because the infiniteLoop goroutine never yields.
  </p>
  <h3>The Evolution of Go's Scheduling Model</h3>
  <div class="characteristics">
    <p>Go's scheduling model has evolved significantly:</p>
    <ul>
      <li>
        <span class="key-term">Go 1.0-1.1:</span> Purely cooperative scheduling
      </li>
      <li>
        <span class="key-term">Go 1.2-1.13:</span> Cooperative with limited
        preemption at function calls
      </li>
      <li>
        <span class="key-term">Go 1.14+:</span> Asynchronous preemption added
      </li>
    </ul>
  </div>
  <div class="navigation-buttons">
    <button class="nav-button" onclick="navigate('prev')">Previous</button>
    <button class="nav-button" onclick="navigate('next')">Next</button>
  </div>
</div>
