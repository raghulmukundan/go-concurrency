<div class="section">
  <h1>Cooperative Scheduling in Go</h1>
  <p>
    Goroutines in Go rely on a cooperative scheduling model, a cornerstone of
    their execution efficiency. Unlike preemptive scheduling, where the
    operating system forcibly interrupts threads, cooperative scheduling means a
    goroutine keeps running until it voluntarily yields control to the
    scheduler. This cooperation keeps context switching lightweight—often just
    hundreds of nanoseconds compared to microseconds for OS threads.
  </p>
  <p>
    Yield points are built into the runtime and occur naturally at specific
    moments in your code, allowing the scheduler to pause one goroutine and run
    another. Let's explore the key places where this happens, with examples and
    exercises to bring it to life.
  </p>
  <h2>Key Yield Points</h2>
  <h3>Function Calls</h3>
  <p>
    The Go compiler inserts scheduler checks at select function call boundaries,
    such as non-inlined calls. When a goroutine calls a function, the runtime
    might decide it's a good time to pause it and switch to another runnable
    goroutine. Not every call yields—optimizations like inlining can skip
    this—but it's a common point where cooperation happens.
  </p>
  <div class="code-section" style="margin: 1em 0 0 0">
    <div
      id="function-yield"
      class="code-container"
      data-code-path="cooperative-scheduling/function-yield.go"
    ></div>
  </div>
  <div class="observation-section">
    <div class="observation-header">
      <i class="fa-solid fa-eye"></i>
      <h4>Observation</h4>
    </div>
    <p>
      "Main runs!" often prints first because
      <span class="code-inline">sayHi()</span> gives the scheduler a chance to
      switch.
    </p>
  </div>
  <h3>Blocking Operations</h3>
  <p>
    Operations that inherently block—like reading from or writing to a channel
    (<span class="code-inline"><-ch</span>), locking a mutex, or calling
    <span class="code-inline">time.Sleep()</span>—cause the goroutine to yield.
    When a goroutine can't proceed (e.g., waiting for a channel receiver), the
    runtime detects this and schedules another runnable goroutine. This includes
    network calls or file I/O, which block on underlying system operations.
  </p>
  <div class="navigation-buttons">
    <button class="nav-button" onclick="navigate('prev')">Previous</button>
    <button class="nav-button" onclick="navigate('next')">Next</button>
  </div>
</div>
